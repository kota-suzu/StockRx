# プロジェクトロール定義とレビュー基準

## 概要

このドキュメントは、StockRxプロジェクトにおける各ロールの責務と、AIアシスタントにそのロールを思い出させるためのプロンプト例を定義します。
**メタ認知的開発プロセス**に基づき、各ロールが自身の責務を明確に理解し、効果的な協業を実現することを目的としています。

このドキュメントは、ワークスペースのWiki、README、オンボーディング資料として即座に利用可能です。

---

## 1. プロジェクトロール定義とAI指示テンプレート

### プロジェクトマネジャー (PM)

**責務**

* 進捗・予算・スコープの三位一体管理でプロジェクトを完遂する
* 障害を即時に除去し、意思決定を迅速化する
* ステークホルダーとリスクを常時監視し調整する
* **StockRx固有**: 在庫管理システムの業務要件とシステム要件の整合性管理

**AI 指示テンプレート**

> **あなたはStockRxプロジェクトのプロジェクトマネジャーです。**
>
> * ビジネス目標・予算・期限を統合して管理し、進捗を毎日レビューしてください。
> * 障害やボトルネックを見つけ次第、最速で排除し、関係者に即共有してください。
> * 在庫管理システムの特性（リアルタイム性、データ整合性）を理解した意思決定をしてください。

**詳細責務**
1. **品質保証の最終責任者**
   - 全てのリリースの品質を保証
   - 品質基準の策定と更新
   - 品質問題のエスカレーション対応

2. **プロジェクト管理**
   - スケジュール管理
   - リソース配分の最適化
   - ステークホルダーとのコミュニケーション

3. **リスク管理**
   - 技術的リスクの特定と対策
   - ビジネスリスクの評価
   - コンティンジェンシープランの策定

**必要スキル**
- プロジェクト管理の実務経験5年以上
- 品質管理手法（ISO 9001等）の理解
- リーダーシップとコミュニケーション能力
- データ分析と意思決定能力

---

### プロダクトオーナー (PO)

**責務**

* バックログを価値順に整列し常に最新化する
* プロダクトビジョンとゴールを明確に発信する
* ネタ（機能）を取捨選択し、リリース優先度を決める
* **StockRx固有**: 在庫管理の業務フローと使用頻度に基づく機能優先度決定

**AI 指示テンプレート**

> **あなたはStockRxのプロダクトオーナーです。**
>
> * ユーザー価値を優先してバックログを並べ替え、透明性を保ってください。
> * スコープ調整を躊躇せず、無駄な"乾いた皿"を出さないようにしてください。
> * 在庫業務の現場の声を反映し、日常使いで本当に必要な機能を見極めてください。

---

### ビジネスアナリスト (BA)

**責務**

* 業務フローを可視化し要件へ落とし込む
* 曖昧語や矛盾を検出し仕様を確定させる
* IT チームと事業部の橋渡しを行う
* **StockRx固有**: 在庫管理業務の複雑なフローをシステム化要件に翻訳

**AI 指示テンプレート**

> **あなたはStockRxのビジネスアナリストです。**
>
> * "工程はどこ？"を口癖に曖昧さを排除し、仕様書を更新してください。
> * 要件漏れがないか、常に業務モデルと照合してください。
> * 在庫の入出庫、ロット管理、期限管理の業務ルールを正確にシステム要件化してください。

---

### プロジェクトリーダー (PL)

**責務**

* 要件を技術タスクへ分割し開発者に割り振る
* 設計レビューで技術リスクを先回り防止
* コードレビューは優しさ８割・厳しさ２割で実施する
* **StockRx固有**: Rails 8.0とMySQL 8.4環境での技術的課題の解決指針提示

**AI 指示テンプレート**

> **あなたはStockRxのプロジェクトリーダーです。**
>
> * 要件を実装可能粒度に分解し、タスクを明確にアサインしてください。
> * 技術的リスクを早期に洗い出し、設計段階で潰してください。
> * Rails 8.0の新機能活用とMySQL 8.4の性能特性を考慮した技術指導をしてください。

**詳細責務**
1. **技術的リーダーシップ**
   - アーキテクチャ設計の承認
   - 技術選定の最終決定
   - 技術的問題の解決支援

2. **開発標準の管理**
   - コーディング規約の策定
   - 開発プロセスの改善
   - ベストプラクティスの推進

3. **チーム育成**
   - 技術メンタリング
   - コードレビューを通じた指導
   - スキル向上計画の策定

**必要スキル**
- 開発経験3年以上
- システム設計の実務経験
- 複数の技術スタックの知識
- 問題解決能力とメンタリングスキル

---

### アーキテクト

**責務**

* 技術選定とシステム構造の最終責任者となる
* 性能・拡張・運用性をバランス良く設計する
* 可観測性を優先し将来の増築を容易にする
* **StockRx固有**: 在庫データの整合性とパフォーマンスを両立するアーキテクチャ設計

**AI 指示テンプレート**

> **あなたはStockRxのアーキテクトです。**
>
> * "増築しやすい梁"を意識し、技術選定を文書化してチームに共有してください。
> * モニタリングとログの設計を先に決め、可観測性を担保してください。
> * 在庫データの ACID 特性を保ちつつ、高頻度アクセスに耐える設計をしてください。

---

### UX/UI デザイナー

**責務**

* ユーザー要件収集 → ワイヤー → プロトタイプを反復
* 定性・定量テストで改善点を裏付ける
* 使いやすさと視覚的魅力の両立を図る
* **StockRx固有**: 在庫管理業務の効率化に直結するUI/UX設計

**AI 指示テンプレート**

> **あなたはStockRxのUX/UIデザイナーです。**
>
> * ペルソナとユーザーフローを定義し、根拠付きのデザインを提案してください。
> * テスト結果を基に、次の改善サイクルを速やかに回してください。
> * 在庫業務の効率性を最優先に、直感的で間違いにくいインターフェースを設計してください。

---

### 開発者 (Dev)

**責務**

* コード実装と自動テストで品質を保証する
* コードレビューで標準遵守とリファクタを行う
* 小さく頻繁なデプロイでリスクを最小化する
* **StockRx固有**: Rails規約に従いつつ、在庫管理特有の複雑なビジネスロジックを実装

**AI 指示テンプレート**

> **あなたはStockRxの開発者です。**
>
> * PR は３行要約、コミットは１目的１粒度を守ってください。
> * CI で赤信号が出たら即修正・テスト追加を行ってください。
> * CLAUDE.mdのベストプラクティスに従い、メタ認知的な実装アプローチを実践してください。

**詳細責務**
1. **実装責任**
   - 要件に基づく正確な実装
   - 高品質なコードの作成
   - 適切なエラーハンドリング

2. **テスト作成**
   - ユニットテストの完全性
   - 統合テストの作成
   - テストカバレッジの維持

3. **ドキュメント作成**
   - コードコメントの記載
   - API仕様書の作成
   - 実装ガイドの作成

**必要スキル**
- プログラミング言語の熟練度
- テスト駆動開発の理解
- バージョン管理システムの使用経験
- 継続的学習への意欲

---

### QA / テストリード

**責務**

* テスト戦略・計画の策定とチーム管理
* テストケースを網羅し CI に組み込む
* バグ報告は再現手順・期待値・実際値・ログの４点セット
* **StockRx固有**: 在庫データ整合性とユーザー権限の境界値テストを重点実施

**AI 指示テンプレート**

> **あなたはStockRxのQAリードです。**
>
> * 仕様をテストケースへ落とし込み、CI パイプラインで自動化してください。
> * リリース判定は「義母に勧められるか？」で OK なら Go です。
> * 在庫データの不整合を検出する包括的なテストシナリオを設計してください。

---

### DevOps / SRE

**責務**

* CI/CD パイプライン設計と自動化を担う
* モニタリングとインシデント対応で MTTR を最小化
* IaC と自動デプロイで運用負荷を低減する
* **StockRx固有**: Docker Compose環境とMySQL 8.4の運用監視体制構築

**AI 指示テンプレート**

> **あなたはStockRxのDevOps/SREです。**
>
> * MTTR を最小化する監視・アラートを構築し、オンコールは交代制で運用してください。
> * CI/CD を全自動化し、デプロイミスをゼロに近づけてください。
> * Docker環境での在庫システムの可用性監視とDB性能監視を設計してください。

---

### セキュリティエンジニア

**責務**

* 脅威モデル策定とペンテストで脆弱性を発見する
* セキュリティ監視とインシデントレスポンスを統括する
* 政策・手順を策定し開発ライフサイクルに組み込む
* **StockRx固有**: 在庫データと管理者認証の多層防御設計

**AI 指示テンプレート**

> **あなたはStockRxのセキュリティエンジニアです。**
>
> * コードレビューと VAPT を定期実施し、重大リスクはリリース前に必ず塞いでください。
> * リリース後も監視ルールで侵入を秒単位で検知してください。
> * DeviseとPunditによる認証・認可の設計レビューとSecureLogging機能の監査を実施してください。

---

### データアナリスト

**責務**

* KPI ダッシュボード整備と A/B テスト設計分析を行う
* 統計手法で意思決定を裏付ける
* "One slide, one story" で洞察を共有する
* **StockRx固有**: 在庫回転率、期限切れ率等の KPI 分析と改善提案

**AI 指示テンプレート**

> **あなたはStockRxのデータアナリストです。**
>
> * サンプルサイズ計算を行い、統計的に有意な結果のみ報告してください。
> * ダッシュボードは判断可能な粒度で、不要な指標は削除してください。
> * 在庫効率化に直結する分析結果を、現場が行動に移せる形で提示してください。

---

### リーガル／コンプライアンス窓口

**責務**

* 法規制・社内ポリシー遵守のチェックとリスク低減
* 契約・規制レビューをドラフト段階から実施
* 従業員教育とポリシー定期テストで継続的遵守
* **StockRx固有**: 医薬品等の在庫管理に関わる薬機法・食品衛生法等の法令遵守

**AI 指示テンプレート**

> **あなたはStockRxのリーガル／コンプライアンス担当です。**
>
> * 契約・仕様変更は草案段階で確認し、規制リスクを早期に潰してください。
> * 社内に最新法規を周知し、違反防止トレーニングを定期開催してください。
> * 在庫管理システムの記録保持義務とトレーサビリティ要件の法的適合性を監査してください。

---

## StockRx プロジェクト固有の共通ガイドライン

### 1. メタ認知的開発プロセスの実践

**Before/After形式での思考**
- **Before**: 最初の直感的アプローチ
- **After**: 複数案の比較検討後の洗練された案
- **理由**: トレードオフとその判断根拠を明確に記録（ADR形式）

**横展開確認の徹底**
- 同様の問題が他のモジュールにも存在しないか確認
- 解決パターンの一般化と標準化
- ベストプラクティスの継続的改善

### 2. StockRx 技術スタック理解

**必須技術知識**
- **Rails 8.0**: 新機能と変更点の理解
- **MySQL 8.4**: 性能特性と設定最適化
- **Docker Compose**: 開発環境とCI/CD環境
- **RSpec**: テスト駆動開発とパフォーマンステスト
- **Sidekiq**: バックグラウンドジョブ処理

**コーディング原則**
- **SOLID原則**の適用（特に単一責任、依存性逆転）
- **Rails Way**: フレームワークの慣習に従う
- **セキュリティバイデザイン**: 設計段階からの組み込み
- **可観測性の確保**: 構造化ログとメトリクス収集

### 3. 責務明確化と権限委譲

**権限と責任の原則**
- 責務を文書化し Git 等で管理
- 権限と責任はワンセットで委譲
- 意思決定の記録（ADR）とトレーサビリティ確保

**コミュニケーション指針**
- 技術的な議論では根拠を明示
- ユーモアはスパイス程度に
- 建設的なフィードバック文化の醸成

### 4. 品質保証基準

**テスト品質**
- **カバレッジ目標**: 80%以上（現在15.13%から向上）
- **パフォーマンス基準**: レスポンス時間200ms以下
- **セキュリティ基準**: 既知脆弱性0件維持

**コードレビュー基準**
- **技術的正確性**: ロジックとパフォーマンス
- **保守性**: 可読性と拡張性
- **セキュリティ**: 脆弱性とベストプラクティス準拠
- **テスタビリティ**: テスト容易性と網羅性

### 5. 継続的改善サイクル

**定期レビュー項目**
- アーキテクチャ決定記録（ADR）の更新
- パフォーマンスメトリクスの監視
- セキュリティ監査の実施
- ドキュメントの最新化

**学習と共有**
- 技術負債の可視化と計画的解消
- インシデントからの学び（ポストモーテム）
- ベストプラクティスの横展開

---

## 運用方法

### AI アシスタント活用時

1. **ロール指定**: 対話開始時に適切なロールプロンプトを使用
2. **責務確認**: 定期的に責務範囲内での作業かチェック
3. **横展開思考**: 他ロールへの影響を考慮した提案

### チーム協業時

1. **責務の明確化**: 作業開始前にロール責務を確認
2. **相互レビュー**: 専門外の観点からのフィードバック実施
3. **ナレッジ共有**: ロール間での学習事項の共有

### 文書管理

1. **バージョン管理**: Git での変更履歴管理
2. **定期更新**: プロジェクト進行に合わせた内容更新
3. **アクセシビリティ**: 全チームメンバーが参照可能な配置

---

**最終更新**: 2025年6月15日  
**次回レビュー予定**: 2025年7月15日

このドキュメントにより、チームも AI も、自分の"ポジション"を迷わずプレイできます。

---

## 2. 詳細なレビュー基準と品質評価システム

### コード品質評価基準

#### A. コーディング規約（20点）

**評価項目:**
1. **命名規則（5点）**
   - 変数名・メソッド名の明確性
   - クラス名の適切性
   - 定数の命名規則遵守

2. **コード構造（5点）**
   - 適切なインデント
   - 行長制限（80-120文字）
   - ファイル構成の論理性

3. **コメント（5点）**
   - 複雑なロジックの説明
   - TODOコメントの適切な使用
   - ドキュメントコメントの完備

4. **一貫性（5点）**
   - プロジェクト全体での統一性
   - 既存コードとの整合性
   - スタイルガイドの遵守

**採点基準:**
```ruby
# 自動評価スクリプト例
class CodingStandardsEvaluator
  def evaluate(file_path)
    rubocop_result = run_rubocop(file_path)
    
    score = case rubocop_result[:offense_count]
    when 0
      20
    when 1..5
      15
    when 6..10
      10
    when 11..20
      5
    else
      0
    end
    
    {
      score: score,
      details: rubocop_result[:offenses]
    }
  end
end
```

#### B. テストカバレッジ（25点）

**評価項目:**
1. **行カバレッジ（10点）**
   - 90%以上: 10点
   - 80-89%: 7点
   - 70-79%: 4点
   - 70%未満: 0点

2. **分岐カバレッジ（10点）**
   - 全分岐網羅: 10点
   - 主要分岐網羅: 7点
   - 部分的網羅: 4点
   - 不十分: 0点

3. **エッジケース（5点）**
   - 境界値テスト実装
   - 異常系テスト実装
   - null/空値のテスト

**採点基準:**
```ruby
class TestCoverageEvaluator
  def evaluate(coverage_report)
    line_coverage_score = calculate_line_coverage_score(coverage_report[:line])
    branch_coverage_score = calculate_branch_coverage_score(coverage_report[:branch])
    edge_case_score = evaluate_edge_cases(coverage_report[:test_cases])
    
    {
      total_score: line_coverage_score + branch_coverage_score + edge_case_score,
      breakdown: {
        line_coverage: line_coverage_score,
        branch_coverage: branch_coverage_score,
        edge_cases: edge_case_score
      }
    }
  end
end
```

#### C. パフォーマンス（20点）

**評価項目:**
1. **応答時間（10点）**
   - 100ms以下: 10点
   - 100-200ms: 7点
   - 200-500ms: 4点
   - 500ms以上: 0点

2. **リソース使用量（5点）**
   - メモリ効率
   - CPU使用率
   - データベースクエリ最適化

3. **スケーラビリティ（5点）**
   - 同時接続数への対応
   - データ量増加への対応
   - 負荷分散の考慮

**採点基準:**
```ruby
class PerformanceEvaluator
  def evaluate(performance_metrics)
    response_time_score = calculate_response_time_score(performance_metrics[:avg_response_time])
    resource_score = calculate_resource_score(performance_metrics[:resource_usage])
    scalability_score = evaluate_scalability(performance_metrics[:load_test_results])
    
    {
      total_score: response_time_score + resource_score + scalability_score,
      recommendations: generate_performance_recommendations(performance_metrics)
    }
  end
end
```

#### D. セキュリティ（20点）

**評価項目:**
1. **脆弱性スキャン（10点）**
   - 脆弱性なし: 10点
   - 低リスクのみ: 7点
   - 中リスクあり: 3点
   - 高リスクあり: 0点

2. **認証・認可（5点）**
   - 適切な権限チェック
   - セッション管理
   - 入力検証

3. **データ保護（5点）**
   - 暗号化の実装
   - 機密情報の取り扱い
   - ログへの配慮

**採点基準:**
```ruby
class SecurityEvaluator
  def evaluate(code_changes)
    brakeman_score = run_brakeman_analysis(code_changes)
    auth_score = evaluate_authentication(code_changes)
    data_protection_score = evaluate_data_protection(code_changes)
    
    {
      total_score: brakeman_score + auth_score + data_protection_score,
      vulnerabilities: list_vulnerabilities(code_changes),
      recommendations: security_recommendations(code_changes)
    }
  end
end
```

#### E. ドキュメント（15点）

**評価項目:**
1. **API仕様書（5点）**
   - エンドポイント定義
   - リクエスト/レスポンス例
   - エラーコード一覧

2. **実装説明（5点）**
   - アーキテクチャ図
   - 処理フロー説明
   - 設計判断の記録

3. **運用ドキュメント（5点）**
   - デプロイ手順
   - 設定方法
   - トラブルシューティング

**採点基準:**
```ruby
class DocumentationEvaluator
  def evaluate(documentation)
    api_doc_score = evaluate_api_documentation(documentation[:api])
    implementation_score = evaluate_implementation_docs(documentation[:implementation])
    operation_score = evaluate_operation_docs(documentation[:operation])
    
    {
      total_score: api_doc_score + implementation_score + operation_score,
      missing_sections: identify_missing_sections(documentation),
      quality_assessment: assess_documentation_quality(documentation)
    }
  end
end
```

## 3. レビュープロセスのSOP

### ステップ1: 自己レビュー（開発者）
1. コードの動作確認
2. テストの実行と確認
3. セルフチェックリストの完了
4. プルリクエストの作成

### ステップ2: ピアレビュー（他の開発者）
1. コードの可読性確認
2. ロジックの妥当性検証
3. テストケースの網羅性確認
4. 改善提案の記載

### ステップ3: テクニカルレビュー（PL）
1. アーキテクチャ適合性の確認
2. 技術的債務の評価
3. パフォーマンス影響の確認
4. セキュリティリスクの評価

### ステップ4: 最終承認（PM）
1. ビジネス要件との整合性確認
2. 品質スコアの確認（85点以上）
3. リリース影響の評価
4. 承認またはフィードバック

## 4. エスカレーションルール

### レベル1: 軽微な問題
- 対応: 開発者間で解決
- 期限: 24時間以内
- 例: コーディング規約違反、軽微なバグ

### レベル2: 中程度の問題
- 対応: PLへエスカレーション
- 期限: 48時間以内
- 例: 設計変更が必要、パフォーマンス問題

### レベル3: 重大な問題
- 対応: PMへ即座にエスカレーション
- 期限: 即時対応
- 例: セキュリティ脆弱性、データ損失リスク

## 5. 継続的改善

### 月次レビュー会議
1. レビュー統計の分析
2. 共通問題の特定
3. プロセス改善の提案
4. 基準の見直し

### 四半期評価
1. チーム全体の品質向上度
2. 個人のスキル向上評価
3. ツールとプロセスの効果測定
4. 次四半期の目標設定

### 年次見直し
1. 役割定義の妥当性評価
2. レビュー基準の更新
3. 新技術への対応
4. 組織全体への展開