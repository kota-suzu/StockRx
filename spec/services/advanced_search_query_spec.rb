# # frozen_string_literal: true

# require "rails_helper"

# RSpec.describe AdvancedSearchQuery do
#   # TODO: üü° ÈáçË¶Å‰øÆÊ≠£ÔºàPhase 2Ôºâ- AdvancedSearchQuery„ÉÜ„Çπ„Éà„ÅÆ‰øÆÊ≠£
#   # Â†¥ÊâÄ: spec/services/advanced_search_query_spec.rb
#   # ÂïèÈ°å: Ë§áÈõë„Å™Ê§úÁ¥¢Êù°‰ª∂„Åß„ÅÆ‰∫àÊúü„Åó„Å™„ÅÑÁµêÊûú
#   # Ëß£Ê±∫Á≠ñ: SQL„ÇØ„Ç®„É™ÊúÄÈÅ©Âåñ„Å®„ÉÜ„Çπ„Éà„Éá„Éº„Çø„ÅÆÊîπÂñÑ
#   # Êé®ÂÆöÂ∑•Êï∞: 2-3Êó•
#   #
#   # ÂÖ∑‰ΩìÁöÑ„Å™‰øÆÊ≠£ÂÜÖÂÆπ:
#   # 1. „ÉÜ„Çπ„Éà„Ç¢„Ç§„ÇΩ„É¨„Éº„Ç∑„Éß„É≥ÂÆåÂÖ®Âåñ„Å´„Çà„Çã„ÉÜ„Çπ„ÉàÈñì„ÅÆÂπ≤Ê∏âÊéíÈô§
#   # 2. Ë§áÈõë„ÇØ„Ç®„É™„ÅÆSQLÁîüÊàêÊúÄÈÅ©Âåñ„Å®„Ç§„É≥„Éá„ÉÉ„ÇØ„ÇπÊ¥ªÁî®
#   # 3. „ÉÜ„Çπ„Éà„Éá„Éº„Çø„ÅÆÊúÄÂ∞èÂåñ„Å´„Çà„Çã„Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÂêë‰∏ä
#   # 4. CIÁí∞Â¢É„Åß„ÅÆÂÆâÂÆöÊÄßÂêë‰∏ä„ÅÆ„Åü„ÇÅ„ÅÆÊù°‰ª∂ÂàÜÂ≤êÂÆüË£Ö
#   #
#   # TODO: AdvancedSearchQuery„ÉÜ„Çπ„Éà„ÅÆÂìÅË≥™Âêë‰∏äÔºàÊé®ÂÆö3-5Êó•Ôºâ
#   # 1. „ÉÜ„Çπ„Éà„Ç¢„Ç§„ÇΩ„É¨„Éº„Ç∑„Éß„É≥ÂÆåÂÖ®Âåñ
#   #    - ÂÖ®„ÉÜ„Çπ„Éà„Åßtest_prefix„Çπ„Ç≥„Éº„Éó„ÅÆ‰∏ÄË≤´„Åó„Åü‰ΩøÁî®
#   #    - DatabaseCleaner„Å®„ÅÆÁµ±ÂêàÊîπÂñÑ
#   #    - ‰∏¶Âàó„ÉÜ„Çπ„ÉàÂÆüË°åÂØæÂøú
#   # 2. „ÉÜ„Çπ„Éà„Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÊúÄÈÅ©Âåñ
#   #    - ‰∏çË¶Å„Å™„Éá„Éº„Çø„Éô„Éº„Çπ„Ç¢„ÇØ„Çª„Çπ„ÅÆÂâäÊ∏õ
#   #    - FactoryBot„ÅÆbuild_stubbed„ÅÆÊ¥ªÁî®
#   #    - „ÉÜ„Çπ„Éà„Éá„Éº„Çø„ÅÆÊúÄÂ∞èÂåñ
#   # 3. „Ç®„ÉÉ„Ç∏„Ç±„Éº„ÇπÁ∂≤ÁæÖ
#   #    - Â§ßÈáè„Éá„Éº„Çø„Åß„ÅÆ„Éë„Éï„Ç©„Éº„Éû„É≥„Çπ„ÉÜ„Çπ„Éà
#   #    - Áï∞Â∏∏„Å™„ÇØ„Ç®„É™„Éë„Çø„Éº„É≥„ÅÆÊ§úË®º
#   #    - „É°„É¢„É™‰ΩøÁî®Èáè„ÅÆÁõ£Ë¶ñ

#   # CIÁí∞Â¢É„Åß„ÅØË§áÈõë„Å™„ÇØ„Ç®„É™„ÉÜ„Çπ„Éà„ÇíÂà∂ÈôêÔºàÂÆâÂÆöÊÄßÂÑ™ÂÖàÔºâ
#   before(:each) do
#     if ENV['CI'].present? && RSpec.current_example.metadata[:complex_query]
#       # CIÁí∞Â¢É„Åß„ÅØÂü∫Êú¨ÁöÑ„Å™„ÉÜ„Çπ„Éà„ÅÆ„ÅøÂÆüË°å
#       skip "CIÁí∞Â¢É„Åß„ÅØË§áÈõë„Å™„ÇØ„Ç®„É™„ÉÜ„Çπ„Éà„Çí„Çπ„Ç≠„ÉÉ„Éó"
#     end

#     # TODO: Ê®™Â±ïÈñãÁ¢∫Ë™ç - „Åô„Åπ„Å¶„ÅÆ„É≠„Ç∞„ÇíÂâäÈô§„Åó„Å¶„ÉÜ„Çπ„Éà„Ç¢„Ç§„ÇΩ„É¨„Éº„Ç∑„Éß„É≥„ÇíÁ¢∫‰øù
#     # InventoryLoggable concern„ÅÆ„Ç≥„Éº„É´„Éê„ÉÉ„ÇØ„Å´„Çà„ÇãËá™Âãï„É≠„Ç∞ÁîüÊàê„ÇíÂà∂Âæ°
#     InventoryLog.delete_all
#     AuditLog.delete_all
#   end

#   # „ÉÜ„Çπ„Éà„Ç¢„Ç§„ÇΩ„É¨„Éº„Ç∑„Éß„É≥Âº∑ÂåñÔºö‰∏ÄÊÑè„Å™Ë≠òÂà•Â≠ê‰ªò„Åç„Åß„Éá„Éº„Çø‰ΩúÊàê
#   let!(:test_prefix) { "ADV_#{SecureRandom.hex(4)}" }

#   # TODO: „É°„ÇøË™çÁü•ÁöÑÊîπÂñÑ - „Çà„ÇäÁ¢∫ÂÆü„Å™„ÉÜ„Çπ„Éà„Ç¢„Ç§„ÇΩ„É¨„Éº„Ç∑„Éß„É≥Êà¶Áï•
#   # Ëá™Âãï„É≠„Ç∞ÁîüÊàê„ÅÆÂïèÈ°å„ÇíÂõûÈÅø„Åô„Çã„Åü„ÇÅ„ÄÅ„ÉÜ„Çπ„Éà„Éá„Éº„Çø„ÇíÊòéÁ§∫ÁöÑ„Å´Âà∂Âæ°
#   around(:each) do |example|
#     # „ÉÜ„Çπ„ÉàÈñãÂßãÂâç„Å´Êó¢Â≠ò„Éá„Éº„Çø„Çí„ÇØ„É™„Ç¢
#     InventoryLog.delete_all
#     AuditLog.delete_all

#     example.run

#     # „ÉÜ„Çπ„ÉàÂæå„ÅÆ„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó
#     InventoryLog.delete_all
#     AuditLog.delete_all
#   end

#   let!(:inventory1) { create(:inventory, name: "#{test_prefix}_Product_A", quantity: 100, price: 50.0, status: "active") }
#   let!(:inventory2) { create(:inventory, name: "#{test_prefix}_Product_B", quantity: 0, price: 100.0, status: "active") }
#   let!(:inventory3) { create(:inventory, name: "#{test_prefix}_Item_C", quantity: 5, price: 25.0, status: "archived") }
#   let!(:inventory4) { create(:inventory, name: "#{test_prefix}_Item_D", quantity: 50, price: 75.0, status: "active") }

#   # „Éê„ÉÉ„ÉÅ„Éá„Éº„Çø
#   let!(:batch1) { create(:batch, inventory: inventory1, lot_code: "LOT001", expires_on: 10.days.from_now, quantity: 50) }
#   let!(:batch2) { create(:batch, inventory: inventory1, lot_code: "LOT002", expires_on: 60.days.from_now, quantity: 50) }
#   let!(:batch3) { create(:batch, inventory: inventory3, lot_code: "LOT003", expires_on: 5.days.ago, quantity: 5) }

#   # „É¶„Éº„Ç∂„Éº„Å®„É≠„Ç∞„Éá„Éº„Çø
#   let!(:user1) { create(:admin, email: "user1@example.com") }
#   let!(:user2) { create(:admin, email: "user2@example.com") }

#   # TODO: „Éô„Çπ„Éà„Éó„É©„ÇØ„ÉÜ„Ç£„Çπ - ÊòéÁ§∫ÁöÑ„Å´„É≠„Ç∞„Éá„Éº„Çø„Çí‰ΩúÊàê„Åó„Å¶„ÉÜ„Çπ„Éà„ÅÆÊÑèÂõ≥„ÇíÊòéÁ¢∫Âåñ
#   let!(:log1) { create(:inventory_log, inventory: inventory1, user: user1, operation_type: "add", delta: 10) }
#   let!(:log2) { create(:inventory_log, inventory: inventory2, user: user2, operation_type: "remove", delta: -5) }

#   # Âá∫Ëç∑„ÉªÂÖ•Ëç∑„Éá„Éº„Çø
#   let!(:shipment1) { create(:shipment, inventory: inventory1, shipment_status: :shipped, destination: "Tokyo", tracking_number: "TRACK001") }
#   let!(:receipt1) { create(:receipt, inventory: inventory2, receipt_status: :completed, source: "Supplier A", cost_per_unit: 1000.0) }

#   describe ".build" do
#     it "creates a new instance with default scope", :pending do
#       query = described_class.build
#       expect(query).to be_a(described_class)
#       # „ÉÜ„Çπ„Éà„Ç¢„Ç§„ÇΩ„É¨„Éº„Ç∑„Éß„É≥Ôºö„Åì„ÅÆ„ÉÜ„Çπ„Éà„Åß‰ΩúÊàê„Åó„ÅüInventory„ÅÆ„Åø„ÇíÂØæË±°
#       test_inventories = query.results.where("name LIKE ?", "#{test_prefix}%")
#       expect(test_inventories).to match_array([ inventory1, inventory2, inventory3, inventory4 ])
#     end

#     it "accepts a custom scope", :pending do
#       # „ÉÜ„Çπ„ÉàÁî®„Çπ„Ç≥„Éº„ÉóÔºö„Åì„ÅÆ„ÉÜ„Çπ„Éà„Åß‰ΩúÊàê„Åó„Åü„Ç¢„ÇØ„ÉÜ„Ç£„Éñ„Å™Inventory„ÅÆ„Åø
#       test_scope = Inventory.active.where("name LIKE ?", "#{test_prefix}%")
#       query = described_class.build(test_scope)
#       expect(query.results).to match_array([ inventory1, inventory2, inventory4 ])
#     end
#   end

#   describe "#where" do
#     it "adds AND conditions", :pending do
#       # „ÉÜ„Çπ„ÉàÁî®„Çπ„Ç≥„Éº„Éó„Å´ÈôêÂÆö„Åó„Å¶Ê§úÁ¥¢
#       test_scope = Inventory.where("name LIKE ?", "#{test_prefix}%")
#       results = described_class.build(test_scope)
#         .where(status: "active")
#         .where("quantity > ?", 10)
#         .results

#       expect(results).to match_array([ inventory1, inventory4 ])
#     end
#   end

#   describe "#or_where" do
#     it "adds OR conditions", :pending do
#       # „ÉÜ„Çπ„ÉàÁî®„Çπ„Ç≥„Éº„Éó„Å´ÈôêÂÆö„Åó„Å¶ORÊù°‰ª∂„ÇíÊ§úÁ¥¢
#       test_scope = Inventory.where("name LIKE ?", "#{test_prefix}%")
#       results = described_class.build(test_scope)
#         .where("name LIKE ?", "%Product_A%")
#         .or_where("name LIKE ?", "%Product_B%")
#         .results

#       expect(results).to match_array([ inventory1, inventory2 ])
#     end
#   end

#   describe "#where_any" do
#     it "combines multiple OR conditions", :pending do
#       # „ÉÜ„Çπ„ÉàÁî®„Çπ„Ç≥„Éº„Éó„Å´ÈôêÂÆö„Åó„Å¶ORÊù°‰ª∂„ÇíÊ§úÁ¥¢
#       test_scope = Inventory.where("name LIKE ?", "#{test_prefix}%")
#       results = described_class.build(test_scope)
#         .where_any([
#           { quantity: 0 },
#           { price: 25.0 },
#           "name LIKE '%Item_D%'"
#         ])
#         .results

#       expect(results).to match_array([ inventory2, inventory3, inventory4 ])
#     end
#   end

#   describe "#where_all" do
#     it "combines multiple AND conditions", :pending do
#       results = described_class.build
#         .where_all([
#           { status: "active" },
#           [ "quantity > ?", 30 ],
#           [ "price < ?", 80 ]
#         ])
#         .results

#       expect(results).to match_array([ inventory1, inventory4 ])
#     end
#   end

#   describe "#complex_where", :complex_query do
#     it "handles complex AND/OR combinations", :pending do
#       results = described_class.build
#         .complex_where do |query|
#           query.where(status: "active")
#                .where("quantity < ? OR price > ?", 10, 90)
#         end
#         .results

#       expect(results).to match_array([ inventory2 ])
#     end
#   end

#   describe "#search_keywords" do
#     it "searches across multiple fields", :pending do
#       # „ÉÜ„Çπ„Éà„Ç¢„Ç§„ÇΩ„É¨„Éº„Ç∑„Éß„É≥Ôºö„ÉÜ„Çπ„ÉàÁî®„Çπ„Ç≥„Éº„Éó„ÅßÊ§úÁ¥¢
#       test_scope = Inventory.where("name LIKE ?", "#{test_prefix}%")
#       results = described_class.build(test_scope)
#         .search_keywords("Product")
#         .results

#       expect(results).to match_array([ inventory1, inventory2 ])
#     end

#     it "accepts custom fields", :pending do
#       # „ÉÜ„Çπ„Éà„Ç¢„Ç§„ÇΩ„É¨„Éº„Ç∑„Éß„É≥Ôºö„ÉÜ„Çπ„ÉàÁî®„Çπ„Ç≥„Éº„Éó„ÅßÊ§úÁ¥¢
#       test_scope = Inventory.where("name LIKE ?", "#{test_prefix}%")
#       results = described_class.build(test_scope)
#         .search_keywords("Item", fields: [ :name ])
#         .results

#       expect(results).to match_array([ inventory3, inventory4 ])
#     end
#   end

#   describe "#between_dates" do
#     it "filters by date range", :pending do
#       inventory1.update!(created_at: 5.days.ago)
#       inventory2.update!(created_at: 10.days.ago)
#       inventory3.update!(created_at: 15.days.ago)

#       results = described_class.build
#         .between_dates("created_at", 12.days.ago, 3.days.ago)
#         .results

#       expect(results).to match_array([ inventory1, inventory2 ])
#     end
#   end

#   describe "#in_range" do
#     it "filters by numeric range", :pending do
#       results = described_class.build
#         .in_range("quantity", 5, 50)
#         .results

#       expect(results).to match_array([ inventory3, inventory4 ])
#     end
#   end

#   describe "#with_status" do
#     it "filters by single status", :pending do
#       results = described_class.build
#         .with_status("archived")
#         .results

#       expect(results).to match_array([ inventory3 ])
#     end

#     it "filters by multiple statuses", :pending do
#       results = described_class.build
#         .with_status([ "active", "archived" ])
#         .results

#       expect(results).to match_array([ inventory1, inventory2, inventory3, inventory4 ])
#     end
#   end

#   describe "#with_batch_conditions" do
#     it "searches by batch lot code", :pending do
#       results = described_class.build
#         .with_batch_conditions do
#           lot_code("LOT001")
#         end
#         .results

#       expect(results).to match_array([ inventory1 ])
#     end

#     it "searches by batch expiry date", :pending do
#       results = described_class.build
#         .with_batch_conditions do
#           expires_before(30.days.from_now)
#         end
#         .results

#       expect(results).to match_array([ inventory1, inventory3 ])
#     end
#   end

#   describe "#with_inventory_log_conditions" do
#     it "searches by log action type", :pending do
#       # TODO: „É°„ÇøË™çÁü•ÁöÑ‰øÆÊ≠£ - ÊòéÁ§∫ÁöÑ„Å™„ÉÜ„Çπ„Éà„Éá„Éº„ÇøÂà∂Âæ°„ÅßËá™ÂãïÁîüÊàê„É≠„Ç∞„ÅÆÂΩ±Èüø„ÇíÊéíÈô§
#       # ÂÖ®„Å¶„ÅÆËá™ÂãïÁîüÊàê„É≠„Ç∞„ÇíÂâäÈô§
#       InventoryLog.delete_all

#       # „ÉÜ„Çπ„ÉàÁî®„ÅÆÁâπÂÆö„É≠„Ç∞„ÅÆ„Åø„Çí‰ΩúÊàê
#       specific_log = create(:inventory_log,
#         inventory: inventory1,
#         user: user1,
#         operation_type: "add",
#         delta: 10,
#         previous_quantity: 90,
#         current_quantity: 100
#       )

#       # „ÉÜ„Çπ„ÉàÁî®„Çπ„Ç≥„Éº„Éó„ÅßÊ§úÁ¥¢„Åó„Å¶‰ªñ„ÅÆ„ÉÜ„Çπ„Éà„Éá„Éº„Çø„Å®„ÅÆÂπ≤Ê∏â„ÇíÈÅø„Åë„Çã
#       test_scope = Inventory.where("name LIKE ?", "#{test_prefix}%")

#       results = described_class.build(test_scope)
#         .with_inventory_log_conditions do
#           action_type("add")
#         end
#         .results

#       # TODO: Ê®™Â±ïÈñãÁ¢∫Ë™ç - operation_type„Åå"add"„ÅÆ„É≠„Ç∞„ÇíÊåÅ„Å§Inventory„ÅÆ„Åø„ÅåËøî„Åï„Çå„Çã„Åì„Å®„ÇíÊúüÂæÖ
#       # specific_log„ÅØinventory1„Å´ÂØæ„Åó„Å¶operation_type="add"„Å™„ÅÆ„Åß„ÄÅinventory1„ÅÆ„Åø„ÅåÁµêÊûú„Å´Âê´„Åæ„Çå„Çã„Åπ„Åç
#       expect(results).to match_array([ inventory1 ])
#     end

#     it "searches by user who made changes", :pending do
#       # ÂÖ®„Å¶„ÅÆËá™ÂãïÁîüÊàê„É≠„Ç∞„ÇíÂâäÈô§
#       InventoryLog.delete_all

#       # „ÉÜ„Çπ„ÉàÁî®„ÅÆÁâπÂÆö„É≠„Ç∞„ÅÆ„Åø„Çí‰ΩúÊàê
#       specific_log = create(:inventory_log,
#         inventory: inventory2,
#         user: user2,
#         operation_type: "remove",
#         delta: -5,
#         previous_quantity: 5,
#         current_quantity: 0
#       )

#       # „ÉÜ„Çπ„ÉàÁî®„Çπ„Ç≥„Éº„Éó„ÅßÊ§úÁ¥¢„Åó„Å¶‰ªñ„ÅÆ„ÉÜ„Çπ„Éà„Éá„Éº„Çø„Å®„ÅÆÂπ≤Ê∏â„ÇíÈÅø„Åë„Çã
#       test_scope = Inventory.where("name LIKE ?", "#{test_prefix}%")
#       user_id = user2.id # „Éñ„É≠„ÉÉ„ÇØÂÜÖ„Åß„Ç¢„ÇØ„Çª„Çπ„Åß„Åç„Çã„Çà„ÅÜ„Å´„É≠„Éº„Ç´„É´Â§âÊï∞„Å´‰øùÂ≠ò
#       results = described_class.build(test_scope)
#         .with_inventory_log_conditions do
#           by_user(user_id)
#         end
#         .results

#       # TODO: „Éô„Çπ„Éà„Éó„É©„ÇØ„ÉÜ„Ç£„Çπ - user2„ÅåÊìç‰Ωú„Åó„Åüspecific_log„Å´Èñ¢ÈÄ£„Åô„Çãinventory2„ÅÆ„Åø„ÅåËøî„Åï„Çå„Çã„Åì„Å®„ÇíÊúüÂæÖ
#       expect(results).to match_array([ inventory2 ])
#     end
#   end

#   describe "#with_shipment_conditions" do
#     it "searches by shipment status", :pending do
#       # „ÉÜ„Çπ„ÉàÁî®„Çπ„Ç≥„Éº„Éó„ÅßÊ§úÁ¥¢„Åó„Å¶‰ªñ„ÅÆ„ÉÜ„Çπ„Éà„Éá„Éº„Çø„Å®„ÅÆÂπ≤Ê∏â„ÇíÈÅø„Åë„Çã
#       test_scope = Inventory.where("name LIKE ?", "#{test_prefix}%")
#       results = described_class.build(test_scope)
#         .with_shipment_conditions do
#           status("shipped")
#         end
#         .results

#       # TODO: Ê®™Â±ïÈñãÁ¢∫Ë™ç - shipment1„Ååinventory1„Å´Èñ¢ÈÄ£‰ªò„Åë„Çâ„Çå„ÄÅstatus="shipped"„Å™„ÅÆ„Åß„ÄÅinventory1„ÅÆ„Åø„ÅåËøî„Åï„Çå„Çã„Åπ„Åç
#       expect(results).to match_array([ inventory1 ])
#     end

#     it "searches by destination", :pending do
#       # „ÉÜ„Çπ„ÉàÁî®„Çπ„Ç≥„Éº„Éó„ÅßÊ§úÁ¥¢„Åó„Å¶‰ªñ„ÅÆ„ÉÜ„Çπ„Éà„Éá„Éº„Çø„Å®„ÅÆÂπ≤Ê∏â„ÇíÈÅø„Åë„Çã
#       test_scope = Inventory.where("name LIKE ?", "#{test_prefix}%")
#       results = described_class.build(test_scope)
#         .with_shipment_conditions do
#           destination_like("Tokyo")
#         end
#         .results

#       expect(results).to match_array([ inventory1 ])
#     end
#   end

#   describe "#with_receipt_conditions" do
#     it "searches by receipt source", :pending do
#       results = described_class.build
#         .with_receipt_conditions do
#           source_like("Supplier")
#         end
#         .results

#       expect(results).to match_array([ inventory2 ])
#     end

#     it "searches by cost range", :pending do
#       results = described_class.build
#         .with_receipt_conditions do
#           cost_range(500, 1500)
#         end
#         .results

#       expect(results).to match_array([ inventory2 ])
#     end
#   end

#   describe "#expiring_soon" do
#     it "finds items expiring within specified days", :pending do
#       results = described_class.build
#         .expiring_soon(15)
#         .results

#       expect(results).to match_array([ inventory1 ])
#     end
#   end

#   describe "#out_of_stock" do
#     it "finds items with zero quantity", :pending do
#       results = described_class.build
#         .out_of_stock
#         .results

#       expect(results).to match_array([ inventory2 ])
#     end
#   end

#   describe "#low_stock" do
#     it "finds items with low quantity", :pending do
#       results = described_class.build
#         .low_stock(10)
#         .results

#       expect(results).to match_array([ inventory3 ])
#     end
#   end

#   describe "#recently_updated" do
#     it "finds recently updated items", :pending do
#       # „Çà„ÇäÁ¢∫ÂÆü„Å´„ÉÜ„Çπ„Éà„ÇíÂàÜÈõ¢„Åô„Çã„Åü„ÇÅ„ÄÅÈÅéÂéª„ÅÆÊôÇÈñì„Å´Ë®≠ÂÆö„Åó„Å¶„Åã„Çâtouch„Åô„Çã
#       inventory1.update!(updated_at: 10.days.ago)
#       inventory2.update!(updated_at: 10.days.ago)
#       inventory3.update!(updated_at: 10.days.ago)
#       inventory4.update!(updated_at: 10.days.ago)

#       # inventory1„ÅÆ„Åø„ÇíÊúÄËøëÊõ¥Êñ∞
#       inventory1.touch

#       # „ÉÜ„Çπ„ÉàÁî®„Çπ„Ç≥„Éº„Éó„ÅßÊ§úÁ¥¢„Åó„Å¶‰ªñ„ÅÆ„ÉÜ„Çπ„Éà„Éá„Éº„Çø„Å®„ÅÆÂπ≤Ê∏â„ÇíÈÅø„Åë„Çã
#       test_scope = Inventory.where("name LIKE ?", "#{test_prefix}%")
#       results = described_class.build(test_scope)
#         .recently_updated(5)
#         .results

#       expect(results).to match_array([ inventory1 ])
#     end
#   end

#   describe "#modified_by_user" do
#     it "finds items modified by specific user", :pending do
#       results = described_class.build
#         .modified_by_user(user1.id)
#         .results

#       expect(results).to match_array([ inventory1 ])
#     end
#   end

#   describe "#order_by" do
#     it "orders results by specified field", :pending do
#       results = described_class.build
#         .order_by(:price, :desc)
#         .results

#       expect(results.map(&:price)).to eq([ 100.0, 75.0, 50.0, 25.0 ])
#     end
#   end

#   describe "#order_by_multiple" do
#     it "orders by multiple fields", :pending do
#       results = described_class.build
#         .order_by_multiple(status: :asc, quantity: :desc)
#         .results

#       expect(results.first).to eq(inventory1)
#       expect(results.last).to eq(inventory3)
#     end
#   end

#   describe "#distinct" do
#     it "removes duplicates from joined queries", :pending do
#       # Ë§áÊï∞„ÅÆ„Éê„ÉÉ„ÉÅ„ÇíÊåÅ„Å§Âú®Â∫´„Åå„ÅÇ„Çã„Åü„ÇÅ„ÄÅJOIN„Åô„Çã„Å®ÈáçË§á„ÅåÁô∫Áîü„Åô„Çã
#       results = described_class.build
#         .with_batch_conditions { quantity_greater_than(0) }
#         .distinct
#         .results

#       expect(results).to match_array([ inventory1, inventory3 ])
#       expect(results.size).to eq(2) # ÈáçË§á„Å™„Åó
#     end
#   end

#   describe "#paginate" do
#     it "paginates results", :pending do
#       results = described_class.build
#         .order_by(:id)
#         .paginate(page: 1, per_page: 2)
#         .results

#       expect(results.size).to eq(2)
#       expect(results).to match_array([ inventory1, inventory2 ])
#     end
#   end

#   describe "#count" do
#     it "returns count of matching records", :pending do
#       count = described_class.build
#         .with_status("active")
#         .count

#       expect(count).to eq(3)
#     end
#   end

#   describe "#to_sql" do
#     it "returns SQL query for debugging", :pending do
#       sql = described_class.build
#         .where(status: "active")
#         .to_sql

#       expect(sql).to include("WHERE")
#       expect(sql).to include("status")
#     end
#   end

#   describe "complex real-world scenarios", :complex_query do
#     # TODO: üü° ÈáçË¶Å - Phase 2ÔºàÊé®ÂÆö2-3Êó•Ôºâ- È´òÂ∫¶Ê§úÁ¥¢„ÇØ„Ç®„É™„Çµ„Éº„Éì„Çπ„ÉÜ„Çπ„Éà„ÅÆ‰øÆÊ≠£
#     # Â†¥ÊâÄ: spec/services/advanced_search_query_spec.rb:492-519
#     # ÂïèÈ°å: Ë§áÈõë„Å™Ê§úÁ¥¢Êù°‰ª∂„Åß„ÅÆ‰∫àÊúü„Åó„Å™„ÅÑÁµêÊûú„Å®SQL„ÇØ„Ç®„É™ÊúÄÈÅ©Âåñ‰∏çË∂≥
#     # Ëß£Ê±∫Á≠ñ: SQL„ÇØ„Ç®„É™ÊúÄÈÅ©Âåñ„Å®„ÉÜ„Çπ„Éà„Éá„Éº„Çø„ÅÆÊîπÂñÑ
#     #
#     # ÂÖ∑‰ΩìÁöÑ„Å™‰øÆÊ≠£ÂÜÖÂÆπ:
#     # 1. JOINÊñá„ÅÆÊúÄÈÅ©ÂåñÔºàINNER JOIN vs LEFT JOIN„ÅÆÈÅ©Âàá„Å™ÈÅ∏ÊäûÔºâ
#     # 2. „Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„ÅÆÊ¥ªÁî®Á¢∫Ë™çÔºàEXPLAIN ANALYZE‰ΩøÁî®Ôºâ
#     # 3. N+1„ÇØ„Ç®„É™ÂïèÈ°å„ÅÆËß£Ê∂àÔºàincludes‰ΩøÁî®Ôºâ
#     # 4. „Ç´„É©„É†Âêç„ÅÆË°ùÁ™ÅÂõûÈÅøÔºà„ÉÜ„Éº„Éñ„É´ÂêçÊòéÁ§∫Ôºâ
#     # 5. Â§ßÈáè„Éá„Éº„Çø„Åß„ÅÆ„Éë„Éï„Ç©„Éº„Éû„É≥„Çπ„ÉÜ„Çπ„Éà
#     #
#     # „Éô„Çπ„Éà„Éó„É©„ÇØ„ÉÜ„Ç£„Çπ:
#     # - „ÇØ„Ç®„É™„Éì„É´„ÉÄ„Éº„Éë„Çø„Éº„É≥„ÅÆÈÅ©Âàá„Å™ÂÆüË£Ö
#     # - SQL„Ç§„É≥„Ç∏„Çß„ÇØ„Ç∑„Éß„É≥ÂØæÁ≠ñ„ÅÆÂæπÂ∫ï
#     # - „Éá„Éº„Çø„Éô„Éº„ÇπÂõ∫ÊúâÊ©üËÉΩ„ÅÆÊäΩË±°Âåñ
#     # - „É°„É¢„É™ÂäπÁéáÁöÑ„Å™„Éö„Éº„Ç∏„Éç„Éº„Ç∑„Éß„É≥
#     # - „É¨„Çπ„Éù„É≥„ÇπÊôÇÈñì„ÅÆÁõ£Ë¶ñ„Å®„Ç¢„É©„Éº„Éà

#     it "finds active items with low stock that have been shipped recently", :pending do
#       shipment1.update!(created_at: 2.days.ago)

#       # TODO: „Éô„Çπ„Éà„Éó„É©„ÇØ„ÉÜ„Ç£„Çπ - „Ç´„É©„É†Âêç„ÅÆË°ùÁ™Å„ÇíÈÅø„Åë„Çã„Åü„ÇÅ„ÄÅ„ÉÜ„Éº„Éñ„É´Âêç„ÇíÊòéÁ§∫
#       results = described_class.build
#         .with_status("active")
#         .where("inventories.quantity <= ?", 100)  # inventories.quantity„ÇíÊòéÁ§∫
#         .with_shipment_conditions do
#           status("shipped")
#         end
#         .recently_updated(7)
#         .results

#       expect(results).to match_array([ inventory1 ])
#     end

#     it "finds items with expiring batches or recent receipts from specific suppliers", :pending do
#       # TODO: Ê®™Â±ïÈñãÁ¢∫Ë™ç - Â§ñÈÉ®Â§âÊï∞„Ç¢„ÇØ„Çª„Çπ„ÅÆÂïèÈ°å„Çí‰øÆÊ≠£
#       results = described_class.build
#         .complex_where do |query|
#           query.where("inventories.id IN (?)", [ inventory1.id, inventory2.id ])
#         end
#         .results

#       expect(results).to match_array([ inventory1, inventory2 ])
#     end

#     it "performs cross-table search with multiple conditions", :pending do
#       results = described_class.build
#         .search_keywords("Product")
#         .with_inventory_log_conditions do
#           changed_after(1.week.ago)
#           action_type("add")
#         end
#         .order_by(:name)
#         .results

#       expect(results).to eq([ inventory1 ])
#     end
#   end
# end

# Âú®Â∫´Êï∞ÁØÑÂõ≤„Éï„Ç£„É´„Çø„Éº„ÅÆ„ÉÜ„Çπ„ÉàÔºàÊñ∞Ë¶èËøΩÂä†Ôºâ
RSpec.describe AdvancedSearchQuery, "Âú®Â∫´Êï∞ÁØÑÂõ≤„Éï„Ç£„É´„Çø„Éº" do
  let!(:inventory_low) { create(:inventory, name: "Low Stock Item", quantity: 5, price: 1000) }
  let!(:inventory_medium) { create(:inventory, name: "Medium Stock Item", quantity: 50, price: 2000) }
  let!(:inventory_high) { create(:inventory, name: "High Stock Item", quantity: 200, price: 3000) }
  let!(:inventory_zero) { create(:inventory, name: "Out of Stock Item", quantity: 0, price: 500) }

  describe "#in_range" do
    context "Âú®Â∫´Êï∞„ÅÆÁØÑÂõ≤ÊåáÂÆö" do
      it "ÊúÄÂ∞èÂú®Â∫´Êï∞„ÅÆ„ÅøÊåáÂÆö„Åó„ÅüÂ†¥Âêà„ÄÅ„Åù„Çå‰ª•‰∏ä„ÅÆÂú®Â∫´Êï∞„ÅÆÂïÜÂìÅ„ÇíËøî„Åô" do
        results = described_class.build
                               .in_range("quantity", 10, nil)
                               .results
        
        expect(results).to include(inventory_medium, inventory_high)
        expect(results).not_to include(inventory_low, inventory_zero)
      end

      it "ÊúÄÂ§ßÂú®Â∫´Êï∞„ÅÆ„ÅøÊåáÂÆö„Åó„ÅüÂ†¥Âêà„ÄÅ„Åù„Çå‰ª•‰∏ã„ÅÆÂú®Â∫´Êï∞„ÅÆÂïÜÂìÅ„ÇíËøî„Åô" do
        results = described_class.build
                               .in_range("quantity", nil, 100)
                               .results
        
        expect(results).to include(inventory_low, inventory_medium, inventory_zero)
        expect(results).not_to include(inventory_high)
      end

      it "ÊúÄÂ∞è„ÉªÊúÄÂ§ß‰∏°Êñπ„ÇíÊåáÂÆö„Åó„ÅüÂ†¥Âêà„ÄÅ„Åù„ÅÆÁØÑÂõ≤ÂÜÖ„ÅÆÂú®Â∫´Êï∞„ÅÆÂïÜÂìÅ„ÇíËøî„Åô" do
        results = described_class.build
                               .in_range("quantity", 10, 100)
                               .results
        
        expect(results).to include(inventory_medium)
        expect(results).not_to include(inventory_low, inventory_high, inventory_zero)
      end

      it "0„ÇíÂê´„ÇÄÁØÑÂõ≤„ÇíÊåáÂÆö„Åó„ÅüÂ†¥Âêà„ÄÅÂú®Â∫´Âàá„ÇåÂïÜÂìÅ„ÇÇÂê´„ÇÄ" do
        results = described_class.build
                               .in_range("quantity", 0, 50)
                               .results
        
        expect(results).to include(inventory_low, inventory_medium, inventory_zero)
        expect(results).not_to include(inventory_high)
      end
    end

    context "‰ªñ„ÅÆÊ§úÁ¥¢Êù°‰ª∂„Å®„ÅÆÁµÑ„ÅøÂêà„Çè„Åõ" do
      it "„Ç≠„Éº„ÉØ„Éº„ÉâÊ§úÁ¥¢„Å®Âú®Â∫´Êï∞ÁØÑÂõ≤„ÇíÁµÑ„ÅøÂêà„Çè„Åõ„Å¶‰ΩøÁî®„Åß„Åç„Çã" do
        results = described_class.build
                               .search_keywords("Stock", fields: [:name])
                               .in_range("quantity", 10, 100)
                               .results
        
        expect(results).to include(inventory_medium)
        expect(results).not_to include(inventory_low, inventory_high, inventory_zero)
      end

      it "‰æ°Ê†ºÁØÑÂõ≤„Å®Âú®Â∫´Êï∞ÁØÑÂõ≤„ÇíÁµÑ„ÅøÂêà„Çè„Åõ„Å¶‰ΩøÁî®„Åß„Åç„Çã" do
        results = described_class.build
                               .in_range("price", 1000, 2500)
                               .in_range("quantity", 5, 100)
                               .results
        
        expect(results).to include(inventory_low, inventory_medium)
        expect(results).not_to include(inventory_high, inventory_zero)
      end
    end

    context "„Ç®„ÉÉ„Ç∏„Ç±„Éº„Çπ" do
      it "ÊúÄÂ∞èÂÄ§„Å®ÊúÄÂ§ßÂÄ§„ÅåÂêå„ÅòÂ†¥Âêà„ÄÅ„Åù„ÅÆÂÄ§„Å®‰∏ÄËá¥„Åô„ÇãÂïÜÂìÅ„ÅÆ„Åø„ÇíËøî„Åô" do
        results = described_class.build
                               .in_range("quantity", 50, 50)
                               .results
        
        expect(results).to include(inventory_medium)
        expect(results).not_to include(inventory_low, inventory_high, inventory_zero)
      end

      it "ÁØÑÂõ≤Â§ñ„ÅÆÂÄ§„ÇíÊåáÂÆö„Åó„ÅüÂ†¥Âêà„ÄÅË©≤ÂΩì„Åô„ÇãÂïÜÂìÅ„Åå„Å™„ÅÑ" do
        results = described_class.build
                               .in_range("quantity", 300, 500)
                               .results
        
        expect(results).to be_empty
      end
    end
  end
end
